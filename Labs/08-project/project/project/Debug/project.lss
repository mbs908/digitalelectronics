
project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000132  00800100  000009de  00000a72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000009de  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000ac  00800232  00800232  00000ba4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ba4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000bd4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000178  00000000  00000000  00000c14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000022a6  00000000  00000000  00000d8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c20  00000000  00000000  00003032  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000100a  00000000  00000000  00003c52  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003a0  00000000  00000000  00004c5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006ce  00000000  00000000  00004ffc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001055  00000000  00000000  000056ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  0000671f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 02 03 	jmp	0x604	; 0x604 <__vector_13>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 fa 03 	jmp	0x7f4	; 0x7f4 <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 58 04 	jmp	0x8b0	; 0x8b0 <__vector_18>
  4c:	0c 94 86 04 	jmp	0x90c	; 0x90c <__vector_19>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	12 e0       	ldi	r17, 0x02	; 2
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee ed       	ldi	r30, 0xDE	; 222
  7c:	f9 e0       	ldi	r31, 0x09	; 9
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 33       	cpi	r26, 0x32	; 50
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	22 e0       	ldi	r18, 0x02	; 2
  8c:	a2 e3       	ldi	r26, 0x32	; 50
  8e:	b2 e0       	ldi	r27, 0x02	; 2
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ae 3d       	cpi	r26, 0xDE	; 222
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 9e 02 	call	0x53c	; 0x53c <main>
  9e:	0c 94 ed 04 	jmp	0x9da	; 0x9da <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <GPIO_config_output>:
}

/*--------------------------------------------------------------------*/
/* GPIO_toggle */
void GPIO_toggle(volatile uint8_t *reg_name, uint8_t pin_num){
	*reg_name = *reg_name ^ (1<<pin_num);
  a6:	fc 01       	movw	r30, r24
  a8:	40 81       	ld	r20, Z
  aa:	21 e0       	ldi	r18, 0x01	; 1
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <GPIO_config_output+0xe>
  b0:	22 0f       	add	r18, r18
  b2:	33 1f       	adc	r19, r19
  b4:	6a 95       	dec	r22
  b6:	e2 f7       	brpl	.-8      	; 0xb0 <GPIO_config_output+0xa>
  b8:	24 2b       	or	r18, r20
  ba:	20 83       	st	Z, r18
  bc:	08 95       	ret

000000be <GPIO_config_input_pullup>:
  be:	fc 01       	movw	r30, r24
  c0:	80 81       	ld	r24, Z
  c2:	21 e0       	ldi	r18, 0x01	; 1
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	02 c0       	rjmp	.+4      	; 0xcc <GPIO_config_input_pullup+0xe>
  c8:	22 0f       	add	r18, r18
  ca:	33 1f       	adc	r19, r19
  cc:	6a 95       	dec	r22
  ce:	e2 f7       	brpl	.-8      	; 0xc8 <GPIO_config_input_pullup+0xa>
  d0:	92 2f       	mov	r25, r18
  d2:	90 95       	com	r25
  d4:	89 23       	and	r24, r25
  d6:	80 83       	st	Z, r24
  d8:	80 81       	ld	r24, Z
  da:	81 81       	ldd	r24, Z+1	; 0x01
  dc:	28 2b       	or	r18, r24
  de:	21 83       	std	Z+1, r18	; 0x01
  e0:	08 95       	ret

000000e2 <GPIO_write_low>:
  e2:	fc 01       	movw	r30, r24
  e4:	90 81       	ld	r25, Z
  e6:	21 e0       	ldi	r18, 0x01	; 1
  e8:	30 e0       	ldi	r19, 0x00	; 0
  ea:	02 c0       	rjmp	.+4      	; 0xf0 <GPIO_write_low+0xe>
  ec:	22 0f       	add	r18, r18
  ee:	33 1f       	adc	r19, r19
  f0:	6a 95       	dec	r22
  f2:	e2 f7       	brpl	.-8      	; 0xec <GPIO_write_low+0xa>
  f4:	20 95       	com	r18
  f6:	29 23       	and	r18, r25
  f8:	20 83       	st	Z, r18
  fa:	08 95       	ret

000000fc <GPIO_write_high>:
  fc:	fc 01       	movw	r30, r24
  fe:	40 81       	ld	r20, Z
 100:	21 e0       	ldi	r18, 0x01	; 1
 102:	30 e0       	ldi	r19, 0x00	; 0
 104:	02 c0       	rjmp	.+4      	; 0x10a <GPIO_write_high+0xe>
 106:	22 0f       	add	r18, r18
 108:	33 1f       	adc	r19, r19
 10a:	6a 95       	dec	r22
 10c:	e2 f7       	brpl	.-8      	; 0x106 <GPIO_write_high+0xa>
 10e:	24 2b       	or	r18, r20
 110:	20 83       	st	Z, r18
 112:	08 95       	ret

00000114 <GPIO_read>:

/*--------------------------------------------------------------------*/
/* GPIO_read */
uint8_t GPIO_read(volatile uint8_t *reg_name, uint8_t pin_num){
	uint8_t input;
	if(bit_is_set(*reg_name,pin_num)){
 114:	fc 01       	movw	r30, r24
 116:	80 81       	ld	r24, Z
		input=1;
	}
	else{
		input=0;
	}
	return(input);	
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	02 c0       	rjmp	.+4      	; 0x120 <GPIO_read+0xc>
 11c:	95 95       	asr	r25
 11e:	87 95       	ror	r24
 120:	6a 95       	dec	r22
 122:	e2 f7       	brpl	.-8      	; 0x11c <GPIO_read+0x8>
 124:	81 70       	andi	r24, 0x01	; 1
 126:	08 95       	ret

00000128 <code_analyzer>:
 * Purpose:  checks if the code introduced matches one of the correct ones
 * Input:    the code introduced and the correct ones
 * Returns:  1 if the code is correct, 0 if not
 **************************************************************************/
uint8_t code_analyzer(char code[4],char correct_code1[4],char correct_code2[4],char correct_code3[4])
{
 128:	ef 92       	push	r14
 12a:	ff 92       	push	r15
 12c:	0f 93       	push	r16
 12e:	1f 93       	push	r17
 130:	cf 93       	push	r28
 132:	df 93       	push	r29
 134:	fc 01       	movw	r30, r24
 136:	06 2f       	mov	r16, r22
 138:	17 2f       	mov	r17, r23
 13a:	c2 2f       	mov	r28, r18
 13c:	d3 2f       	mov	r29, r19
 13e:	e4 2e       	mov	r14, r20
 140:	f5 2e       	mov	r15, r21
 142:	9c 01       	movw	r18, r24
 144:	2c 5f       	subi	r18, 0xFC	; 252
 146:	3f 4f       	sbci	r19, 0xFF	; 255
	
		uint8_t cnt1=0;
		uint8_t cnt2=0;
		uint8_t cnt3=0;
 148:	40 e0       	ldi	r20, 0x00	; 0
 **************************************************************************/
uint8_t code_analyzer(char code[4],char correct_code1[4],char correct_code2[4],char correct_code3[4])
{
	
		uint8_t cnt1=0;
		uint8_t cnt2=0;
 14a:	50 e0       	ldi	r21, 0x00	; 0
 * Returns:  1 if the code is correct, 0 if not
 **************************************************************************/
uint8_t code_analyzer(char code[4],char correct_code1[4],char correct_code2[4],char correct_code3[4])
{
	
		uint8_t cnt1=0;
 14c:	60 e0       	ldi	r22, 0x00	; 0
		uint8_t cnt2=0;
		uint8_t cnt3=0;
		uint8_t equal=0;
		for (uint8_t i=0;i<4;i++)
		{
			if((code[i]==correct_code1[i])){
 14e:	91 91       	ld	r25, Z+
 150:	d8 01       	movw	r26, r16
 152:	8d 91       	ld	r24, X+
 154:	8d 01       	movw	r16, r26
 156:	98 13       	cpse	r25, r24
 158:	01 c0       	rjmp	.+2      	; 0x15c <code_analyzer+0x34>
				cnt1++;
 15a:	6f 5f       	subi	r22, 0xFF	; 255
			}
			
			if((code[i]==correct_code2[i])){
 15c:	d7 01       	movw	r26, r14
 15e:	8d 91       	ld	r24, X+
 160:	7d 01       	movw	r14, r26
 162:	98 13       	cpse	r25, r24
 164:	01 c0       	rjmp	.+2      	; 0x168 <code_analyzer+0x40>
				cnt2++;
 166:	5f 5f       	subi	r21, 0xFF	; 255
			}
			
			if((code[i]==correct_code3[i])){
 168:	89 91       	ld	r24, Y+
 16a:	98 13       	cpse	r25, r24
 16c:	01 c0       	rjmp	.+2      	; 0x170 <code_analyzer+0x48>
				cnt3++;
 16e:	4f 5f       	subi	r20, 0xFF	; 255
	
		uint8_t cnt1=0;
		uint8_t cnt2=0;
		uint8_t cnt3=0;
		uint8_t equal=0;
		for (uint8_t i=0;i<4;i++)
 170:	e2 17       	cp	r30, r18
 172:	f3 07       	cpc	r31, r19
 174:	61 f7       	brne	.-40     	; 0x14e <code_analyzer+0x26>
		if((cnt1==4)|(cnt2==4)|(cnt3==4))//the code is correct if matches one of the correct codes
		{
			equal=1;//CORRECT CODE
		}
		
		return equal;
 176:	91 e0       	ldi	r25, 0x01	; 1
 178:	64 30       	cpi	r22, 0x04	; 4
 17a:	09 f0       	breq	.+2      	; 0x17e <code_analyzer+0x56>
 17c:	90 e0       	ldi	r25, 0x00	; 0
 17e:	81 e0       	ldi	r24, 0x01	; 1
 180:	54 30       	cpi	r21, 0x04	; 4
 182:	09 f0       	breq	.+2      	; 0x186 <code_analyzer+0x5e>
 184:	80 e0       	ldi	r24, 0x00	; 0
 186:	89 2b       	or	r24, r25
 188:	91 e0       	ldi	r25, 0x01	; 1
 18a:	44 30       	cpi	r20, 0x04	; 4
 18c:	09 f0       	breq	.+2      	; 0x190 <code_analyzer+0x68>
 18e:	90 e0       	ldi	r25, 0x00	; 0
		
	
}
 190:	89 2b       	or	r24, r25
 192:	df 91       	pop	r29
 194:	cf 91       	pop	r28
 196:	1f 91       	pop	r17
 198:	0f 91       	pop	r16
 19a:	ff 90       	pop	r15
 19c:	ef 90       	pop	r14
 19e:	08 95       	ret

000001a0 <read_digits>:
 * Input:    none
 * Returns:  the button pressed or 'X' if none button is pressed
 **************************************************************************/
char read_digits(void){
	
	GPIO_write_low(&PORTC,0);
 1a0:	60 e0       	ldi	r22, 0x00	; 0
 1a2:	88 e2       	ldi	r24, 0x28	; 40
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	GPIO_write_high(&PORTC,1);
 1aa:	61 e0       	ldi	r22, 0x01	; 1
 1ac:	88 e2       	ldi	r24, 0x28	; 40
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	GPIO_write_high(&PORTC,2);
 1b4:	62 e0       	ldi	r22, 0x02	; 2
 1b6:	88 e2       	ldi	r24, 0x28	; 40
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	
	if(GPIO_read(&PINC,3)==0){
 1be:	63 e0       	ldi	r22, 0x03	; 3
 1c0:	86 e2       	ldi	r24, 0x26	; 38
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 1c8:	81 11       	cpse	r24, r1
 1ca:	0f c0       	rjmp	.+30     	; 0x1ea <read_digits+0x4a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1cc:	83 ec       	ldi	r24, 0xC3	; 195
 1ce:	99 e0       	ldi	r25, 0x09	; 9
 1d0:	01 97       	sbiw	r24, 0x01	; 1
 1d2:	f1 f7       	brne	.-4      	; 0x1d0 <read_digits+0x30>
 1d4:	00 c0       	rjmp	.+0      	; 0x1d6 <read_digits+0x36>
 1d6:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,3)==0);
 1d8:	63 e0       	ldi	r22, 0x03	; 3
 1da:	86 e2       	ldi	r24, 0x26	; 38
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 1e2:	88 23       	and	r24, r24
 1e4:	c9 f3       	breq	.-14     	; 0x1d8 <read_digits+0x38>
		return '1';
 1e6:	81 e3       	ldi	r24, 0x31	; 49
 1e8:	08 95       	ret
	}
	if(GPIO_read(&PINC,4)==0){
 1ea:	64 e0       	ldi	r22, 0x04	; 4
 1ec:	86 e2       	ldi	r24, 0x26	; 38
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 1f4:	81 11       	cpse	r24, r1
 1f6:	0f c0       	rjmp	.+30     	; 0x216 <read_digits+0x76>
 1f8:	83 ec       	ldi	r24, 0xC3	; 195
 1fa:	99 e0       	ldi	r25, 0x09	; 9
 1fc:	01 97       	sbiw	r24, 0x01	; 1
 1fe:	f1 f7       	brne	.-4      	; 0x1fc <read_digits+0x5c>
 200:	00 c0       	rjmp	.+0      	; 0x202 <read_digits+0x62>
 202:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,4)==0);
 204:	64 e0       	ldi	r22, 0x04	; 4
 206:	86 e2       	ldi	r24, 0x26	; 38
 208:	90 e0       	ldi	r25, 0x00	; 0
 20a:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 20e:	88 23       	and	r24, r24
 210:	c9 f3       	breq	.-14     	; 0x204 <read_digits+0x64>
		return '4';
 212:	84 e3       	ldi	r24, 0x34	; 52
 214:	08 95       	ret
	}
	if(GPIO_read(&PINC,5)==0){
 216:	65 e0       	ldi	r22, 0x05	; 5
 218:	86 e2       	ldi	r24, 0x26	; 38
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 220:	81 11       	cpse	r24, r1
 222:	0f c0       	rjmp	.+30     	; 0x242 <read_digits+0xa2>
 224:	83 ec       	ldi	r24, 0xC3	; 195
 226:	99 e0       	ldi	r25, 0x09	; 9
 228:	01 97       	sbiw	r24, 0x01	; 1
 22a:	f1 f7       	brne	.-4      	; 0x228 <read_digits+0x88>
 22c:	00 c0       	rjmp	.+0      	; 0x22e <read_digits+0x8e>
 22e:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,5)==0);
 230:	65 e0       	ldi	r22, 0x05	; 5
 232:	86 e2       	ldi	r24, 0x26	; 38
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 23a:	88 23       	and	r24, r24
 23c:	c9 f3       	breq	.-14     	; 0x230 <read_digits+0x90>
		return '7';
 23e:	87 e3       	ldi	r24, 0x37	; 55
 240:	08 95       	ret
	}
	if(GPIO_read(&PINC,6)==0){
 242:	66 e0       	ldi	r22, 0x06	; 6
 244:	86 e2       	ldi	r24, 0x26	; 38
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 24c:	81 11       	cpse	r24, r1
 24e:	0f c0       	rjmp	.+30     	; 0x26e <read_digits+0xce>
 250:	83 ec       	ldi	r24, 0xC3	; 195
 252:	99 e0       	ldi	r25, 0x09	; 9
 254:	01 97       	sbiw	r24, 0x01	; 1
 256:	f1 f7       	brne	.-4      	; 0x254 <read_digits+0xb4>
 258:	00 c0       	rjmp	.+0      	; 0x25a <read_digits+0xba>
 25a:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,6)==0);
 25c:	66 e0       	ldi	r22, 0x06	; 6
 25e:	86 e2       	ldi	r24, 0x26	; 38
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 266:	88 23       	and	r24, r24
 268:	c9 f3       	breq	.-14     	; 0x25c <read_digits+0xbc>
		return '*';
 26a:	8a e2       	ldi	r24, 0x2A	; 42
 26c:	08 95       	ret
	}
	
	
	GPIO_write_high(&PORTC,0);
 26e:	60 e0       	ldi	r22, 0x00	; 0
 270:	88 e2       	ldi	r24, 0x28	; 40
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	GPIO_write_low(&PORTC,1);
 278:	61 e0       	ldi	r22, 0x01	; 1
 27a:	88 e2       	ldi	r24, 0x28	; 40
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	GPIO_write_high(&PORTC,2);
 282:	62 e0       	ldi	r22, 0x02	; 2
 284:	88 e2       	ldi	r24, 0x28	; 40
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	
	if(GPIO_read(&PINC,3)==0){
 28c:	63 e0       	ldi	r22, 0x03	; 3
 28e:	86 e2       	ldi	r24, 0x26	; 38
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 296:	81 11       	cpse	r24, r1
 298:	0f c0       	rjmp	.+30     	; 0x2b8 <read_digits+0x118>
 29a:	83 ec       	ldi	r24, 0xC3	; 195
 29c:	99 e0       	ldi	r25, 0x09	; 9
 29e:	01 97       	sbiw	r24, 0x01	; 1
 2a0:	f1 f7       	brne	.-4      	; 0x29e <read_digits+0xfe>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <read_digits+0x104>
 2a4:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,3)==0);
 2a6:	63 e0       	ldi	r22, 0x03	; 3
 2a8:	86 e2       	ldi	r24, 0x26	; 38
 2aa:	90 e0       	ldi	r25, 0x00	; 0
 2ac:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 2b0:	88 23       	and	r24, r24
 2b2:	c9 f3       	breq	.-14     	; 0x2a6 <read_digits+0x106>
		return '2';
 2b4:	82 e3       	ldi	r24, 0x32	; 50
 2b6:	08 95       	ret
	}
	if(GPIO_read(&PINC,4)==0){
 2b8:	64 e0       	ldi	r22, 0x04	; 4
 2ba:	86 e2       	ldi	r24, 0x26	; 38
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 2c2:	81 11       	cpse	r24, r1
 2c4:	0f c0       	rjmp	.+30     	; 0x2e4 <read_digits+0x144>
 2c6:	83 ec       	ldi	r24, 0xC3	; 195
 2c8:	99 e0       	ldi	r25, 0x09	; 9
 2ca:	01 97       	sbiw	r24, 0x01	; 1
 2cc:	f1 f7       	brne	.-4      	; 0x2ca <read_digits+0x12a>
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <read_digits+0x130>
 2d0:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,4)==0);
 2d2:	64 e0       	ldi	r22, 0x04	; 4
 2d4:	86 e2       	ldi	r24, 0x26	; 38
 2d6:	90 e0       	ldi	r25, 0x00	; 0
 2d8:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 2dc:	88 23       	and	r24, r24
 2de:	c9 f3       	breq	.-14     	; 0x2d2 <read_digits+0x132>
		return '5';
 2e0:	85 e3       	ldi	r24, 0x35	; 53
 2e2:	08 95       	ret
	}
	if(GPIO_read(&PINC,5)==0){
 2e4:	65 e0       	ldi	r22, 0x05	; 5
 2e6:	86 e2       	ldi	r24, 0x26	; 38
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 2ee:	81 11       	cpse	r24, r1
 2f0:	0f c0       	rjmp	.+30     	; 0x310 <read_digits+0x170>
 2f2:	83 ec       	ldi	r24, 0xC3	; 195
 2f4:	99 e0       	ldi	r25, 0x09	; 9
 2f6:	01 97       	sbiw	r24, 0x01	; 1
 2f8:	f1 f7       	brne	.-4      	; 0x2f6 <read_digits+0x156>
 2fa:	00 c0       	rjmp	.+0      	; 0x2fc <read_digits+0x15c>
 2fc:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,5)==0);
 2fe:	65 e0       	ldi	r22, 0x05	; 5
 300:	86 e2       	ldi	r24, 0x26	; 38
 302:	90 e0       	ldi	r25, 0x00	; 0
 304:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 308:	88 23       	and	r24, r24
 30a:	c9 f3       	breq	.-14     	; 0x2fe <read_digits+0x15e>
		return '8';
 30c:	88 e3       	ldi	r24, 0x38	; 56
 30e:	08 95       	ret
	}
	if(GPIO_read(&PINC,6)==0){
 310:	66 e0       	ldi	r22, 0x06	; 6
 312:	86 e2       	ldi	r24, 0x26	; 38
 314:	90 e0       	ldi	r25, 0x00	; 0
 316:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 31a:	81 11       	cpse	r24, r1
 31c:	0f c0       	rjmp	.+30     	; 0x33c <read_digits+0x19c>
 31e:	83 ec       	ldi	r24, 0xC3	; 195
 320:	99 e0       	ldi	r25, 0x09	; 9
 322:	01 97       	sbiw	r24, 0x01	; 1
 324:	f1 f7       	brne	.-4      	; 0x322 <read_digits+0x182>
 326:	00 c0       	rjmp	.+0      	; 0x328 <read_digits+0x188>
 328:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,6)==0);
 32a:	66 e0       	ldi	r22, 0x06	; 6
 32c:	86 e2       	ldi	r24, 0x26	; 38
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 334:	88 23       	and	r24, r24
 336:	c9 f3       	breq	.-14     	; 0x32a <read_digits+0x18a>
		return '0';
 338:	80 e3       	ldi	r24, 0x30	; 48
 33a:	08 95       	ret
	}
	
	
	GPIO_write_high(&PORTC,0);
 33c:	60 e0       	ldi	r22, 0x00	; 0
 33e:	88 e2       	ldi	r24, 0x28	; 40
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	GPIO_write_high(&PORTC,1);
 346:	61 e0       	ldi	r22, 0x01	; 1
 348:	88 e2       	ldi	r24, 0x28	; 40
 34a:	90 e0       	ldi	r25, 0x00	; 0
 34c:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	GPIO_write_low(&PORTC,2);
 350:	62 e0       	ldi	r22, 0x02	; 2
 352:	88 e2       	ldi	r24, 0x28	; 40
 354:	90 e0       	ldi	r25, 0x00	; 0
 356:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	if(GPIO_read(&PINC,3)==0){
 35a:	63 e0       	ldi	r22, 0x03	; 3
 35c:	86 e2       	ldi	r24, 0x26	; 38
 35e:	90 e0       	ldi	r25, 0x00	; 0
 360:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 364:	81 11       	cpse	r24, r1
 366:	0f c0       	rjmp	.+30     	; 0x386 <read_digits+0x1e6>
 368:	83 ec       	ldi	r24, 0xC3	; 195
 36a:	99 e0       	ldi	r25, 0x09	; 9
 36c:	01 97       	sbiw	r24, 0x01	; 1
 36e:	f1 f7       	brne	.-4      	; 0x36c <read_digits+0x1cc>
 370:	00 c0       	rjmp	.+0      	; 0x372 <read_digits+0x1d2>
 372:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,3)==0);
 374:	63 e0       	ldi	r22, 0x03	; 3
 376:	86 e2       	ldi	r24, 0x26	; 38
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 37e:	88 23       	and	r24, r24
 380:	c9 f3       	breq	.-14     	; 0x374 <read_digits+0x1d4>
		return '3';
 382:	83 e3       	ldi	r24, 0x33	; 51
 384:	08 95       	ret
	}
	if(GPIO_read(&PINC,4)==0){
 386:	64 e0       	ldi	r22, 0x04	; 4
 388:	86 e2       	ldi	r24, 0x26	; 38
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 390:	81 11       	cpse	r24, r1
 392:	0f c0       	rjmp	.+30     	; 0x3b2 <read_digits+0x212>
 394:	83 ec       	ldi	r24, 0xC3	; 195
 396:	99 e0       	ldi	r25, 0x09	; 9
 398:	01 97       	sbiw	r24, 0x01	; 1
 39a:	f1 f7       	brne	.-4      	; 0x398 <read_digits+0x1f8>
 39c:	00 c0       	rjmp	.+0      	; 0x39e <read_digits+0x1fe>
 39e:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,4)==0);
 3a0:	64 e0       	ldi	r22, 0x04	; 4
 3a2:	86 e2       	ldi	r24, 0x26	; 38
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 3aa:	88 23       	and	r24, r24
 3ac:	c9 f3       	breq	.-14     	; 0x3a0 <read_digits+0x200>
		return '6';
 3ae:	86 e3       	ldi	r24, 0x36	; 54
 3b0:	08 95       	ret
	}
	if(GPIO_read(&PINC,5)==0){
 3b2:	65 e0       	ldi	r22, 0x05	; 5
 3b4:	86 e2       	ldi	r24, 0x26	; 38
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 3bc:	81 11       	cpse	r24, r1
 3be:	0f c0       	rjmp	.+30     	; 0x3de <read_digits+0x23e>
 3c0:	83 ec       	ldi	r24, 0xC3	; 195
 3c2:	99 e0       	ldi	r25, 0x09	; 9
 3c4:	01 97       	sbiw	r24, 0x01	; 1
 3c6:	f1 f7       	brne	.-4      	; 0x3c4 <read_digits+0x224>
 3c8:	00 c0       	rjmp	.+0      	; 0x3ca <read_digits+0x22a>
 3ca:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,5)==0);
 3cc:	65 e0       	ldi	r22, 0x05	; 5
 3ce:	86 e2       	ldi	r24, 0x26	; 38
 3d0:	90 e0       	ldi	r25, 0x00	; 0
 3d2:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 3d6:	88 23       	and	r24, r24
 3d8:	c9 f3       	breq	.-14     	; 0x3cc <read_digits+0x22c>
		return '9';
 3da:	89 e3       	ldi	r24, 0x39	; 57
 3dc:	08 95       	ret
	}
	if(GPIO_read(&PINC,6)==0){
 3de:	66 e0       	ldi	r22, 0x06	; 6
 3e0:	86 e2       	ldi	r24, 0x26	; 38
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 3e8:	81 11       	cpse	r24, r1
 3ea:	0f c0       	rjmp	.+30     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
 3ec:	83 ec       	ldi	r24, 0xC3	; 195
 3ee:	99 e0       	ldi	r25, 0x09	; 9
 3f0:	01 97       	sbiw	r24, 0x01	; 1
 3f2:	f1 f7       	brne	.-4      	; 0x3f0 <read_digits+0x250>
 3f4:	00 c0       	rjmp	.+0      	; 0x3f6 <read_digits+0x256>
 3f6:	00 00       	nop
		_delay_ms(10);
		while(GPIO_read(&PINC,6)==0);
 3f8:	66 e0       	ldi	r22, 0x06	; 6
 3fa:	86 e2       	ldi	r24, 0x26	; 38
 3fc:	90 e0       	ldi	r25, 0x00	; 0
 3fe:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_read>
 402:	88 23       	and	r24, r24
 404:	c9 f3       	breq	.-14     	; 0x3f8 <read_digits+0x258>
		return '#';
 406:	83 e2       	ldi	r24, 0x23	; 35
 408:	08 95       	ret
	}
	
	return 'X';
 40a:	88 e5       	ldi	r24, 0x58	; 88
	
 40c:	08 95       	ret

0000040e <toggle_e>:

    while ( (c = pgm_read_byte(progmem_s++)) )
    {
        lcd_putc(c);
    }
}/* lcd_puts_p */
 40e:	29 9a       	sbi	0x05, 1	; 5
 410:	00 00       	nop
 412:	29 98       	cbi	0x05, 1	; 5
 414:	08 95       	ret

00000416 <lcd_write>:
 416:	cf 93       	push	r28
 418:	c8 2f       	mov	r28, r24
 41a:	66 23       	and	r22, r22
 41c:	11 f0       	breq	.+4      	; 0x422 <lcd_write+0xc>
 41e:	28 9a       	sbi	0x05, 0	; 5
 420:	01 c0       	rjmp	.+2      	; 0x424 <lcd_write+0xe>
 422:	28 98       	cbi	0x05, 0	; 5
 424:	54 9a       	sbi	0x0a, 4	; 10
 426:	55 9a       	sbi	0x0a, 5	; 10
 428:	56 9a       	sbi	0x0a, 6	; 10
 42a:	57 9a       	sbi	0x0a, 7	; 10
 42c:	5f 98       	cbi	0x0b, 7	; 11
 42e:	5e 98       	cbi	0x0b, 6	; 11
 430:	5d 98       	cbi	0x0b, 5	; 11
 432:	5c 98       	cbi	0x0b, 4	; 11
 434:	cc 23       	and	r28, r28
 436:	0c f4       	brge	.+2      	; 0x43a <lcd_write+0x24>
 438:	5f 9a       	sbi	0x0b, 7	; 11
 43a:	c6 fd       	sbrc	r28, 6
 43c:	5e 9a       	sbi	0x0b, 6	; 11
 43e:	c5 fd       	sbrc	r28, 5
 440:	5d 9a       	sbi	0x0b, 5	; 11
 442:	c4 fd       	sbrc	r28, 4
 444:	5c 9a       	sbi	0x0b, 4	; 11
 446:	0e 94 07 02 	call	0x40e	; 0x40e <toggle_e>
 44a:	5f 98       	cbi	0x0b, 7	; 11
 44c:	5e 98       	cbi	0x0b, 6	; 11
 44e:	5d 98       	cbi	0x0b, 5	; 11
 450:	5c 98       	cbi	0x0b, 4	; 11
 452:	c3 fd       	sbrc	r28, 3
 454:	5f 9a       	sbi	0x0b, 7	; 11
 456:	c2 fd       	sbrc	r28, 2
 458:	5e 9a       	sbi	0x0b, 6	; 11
 45a:	c1 fd       	sbrc	r28, 1
 45c:	5d 9a       	sbi	0x0b, 5	; 11
 45e:	c0 fd       	sbrc	r28, 0
 460:	5c 9a       	sbi	0x0b, 4	; 11
 462:	0e 94 07 02 	call	0x40e	; 0x40e <toggle_e>
 466:	5c 9a       	sbi	0x0b, 4	; 11
 468:	5d 9a       	sbi	0x0b, 5	; 11
 46a:	5e 9a       	sbi	0x0b, 6	; 11
 46c:	5f 9a       	sbi	0x0b, 7	; 11
 46e:	8a ef       	ldi	r24, 0xFA	; 250
 470:	8a 95       	dec	r24
 472:	f1 f7       	brne	.-4      	; 0x470 <lcd_write+0x5a>
 474:	cf 91       	pop	r28
 476:	08 95       	ret

00000478 <lcd_command>:
 478:	60 e0       	ldi	r22, 0x00	; 0
 47a:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_write>
 47e:	08 95       	ret

00000480 <lcd_gotoxy>:
 480:	61 11       	cpse	r22, r1
 482:	04 c0       	rjmp	.+8      	; 0x48c <lcd_gotoxy+0xc>
 484:	80 58       	subi	r24, 0x80	; 128
 486:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
 48a:	08 95       	ret
 48c:	80 54       	subi	r24, 0x40	; 64
 48e:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
 492:	08 95       	ret

00000494 <lcd_clrscr>:
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
 49a:	08 95       	ret

0000049c <lcd_putc>:
 49c:	61 e0       	ldi	r22, 0x01	; 1
 49e:	0e 94 0b 02 	call	0x416	; 0x416 <lcd_write>
 4a2:	08 95       	ret

000004a4 <lcd_puts>:
 4a4:	cf 93       	push	r28
 4a6:	df 93       	push	r29
 4a8:	ec 01       	movw	r28, r24
 4aa:	21 96       	adiw	r28, 0x01	; 1
 4ac:	fc 01       	movw	r30, r24
 4ae:	80 81       	ld	r24, Z
 4b0:	88 23       	and	r24, r24
 4b2:	29 f0       	breq	.+10     	; 0x4be <lcd_puts+0x1a>
 4b4:	0e 94 4e 02 	call	0x49c	; 0x49c <lcd_putc>
 4b8:	89 91       	ld	r24, Y+
 4ba:	81 11       	cpse	r24, r1
 4bc:	fb cf       	rjmp	.-10     	; 0x4b4 <lcd_puts+0x10>
 4be:	df 91       	pop	r29
 4c0:	cf 91       	pop	r28
 4c2:	08 95       	ret

000004c4 <lcd_init>:
*                  LCD_DISP_ON_CURSOR      display on, cursor on
*                  LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
*  Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 4c4:	cf 93       	push	r28
 4c6:	c8 2f       	mov	r28, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
 4c8:	20 9a       	sbi	0x04, 0	; 4
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
 4ca:	55 9a       	sbi	0x0a, 5	; 10
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
 4cc:	21 9a       	sbi	0x04, 1	; 4
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
 4ce:	54 9a       	sbi	0x0a, 4	; 10
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
 4d0:	55 9a       	sbi	0x0a, 5	; 10
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
 4d2:	56 9a       	sbi	0x0a, 6	; 10
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
 4d4:	57 9a       	sbi	0x0a, 7	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4d6:	8f e9       	ldi	r24, 0x9F	; 159
 4d8:	9f e0       	ldi	r25, 0x0F	; 15
 4da:	01 97       	sbiw	r24, 0x01	; 1
 4dc:	f1 f7       	brne	.-4      	; 0x4da <lcd_init+0x16>
 4de:	00 c0       	rjmp	.+0      	; 0x4e0 <lcd_init+0x1c>
 4e0:	00 00       	nop
    }
    delay(LCD_DELAY_BOOTUP); /* wait 16ms or more after power-on       */

    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN); // LCD_FUNCTION>>4;
 4e2:	5d 9a       	sbi	0x0b, 5	; 11
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN); // LCD_FUNCTION_8BIT>>4;
 4e4:	5c 9a       	sbi	0x0b, 4	; 11
    lcd_e_toggle();
 4e6:	0e 94 07 02 	call	0x40e	; 0x40e <toggle_e>
 4ea:	81 ee       	ldi	r24, 0xE1	; 225
 4ec:	94 e0       	ldi	r25, 0x04	; 4
 4ee:	01 97       	sbiw	r24, 0x01	; 1
 4f0:	f1 f7       	brne	.-4      	; 0x4ee <lcd_init+0x2a>
 4f2:	00 c0       	rjmp	.+0      	; 0x4f4 <lcd_init+0x30>
 4f4:	00 00       	nop
    delay(LCD_DELAY_INIT); /* delay, busy flag can't be checked here */

    /* repeat last command */
    lcd_e_toggle();
 4f6:	0e 94 07 02 	call	0x40e	; 0x40e <toggle_e>
 4fa:	95 e1       	ldi	r25, 0x15	; 21
 4fc:	9a 95       	dec	r25
 4fe:	f1 f7       	brne	.-4      	; 0x4fc <lcd_init+0x38>
 500:	00 00       	nop
    delay(LCD_DELAY_INIT_REP); /* delay, busy flag can't be checked here */

    /* repeat last command a third time */
    lcd_e_toggle();
 502:	0e 94 07 02 	call	0x40e	; 0x40e <toggle_e>
 506:	85 e1       	ldi	r24, 0x15	; 21
 508:	8a 95       	dec	r24
 50a:	f1 f7       	brne	.-4      	; 0x508 <lcd_init+0x44>
 50c:	00 00       	nop
    delay(LCD_DELAY_INIT_REP); /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN); // LCD_FUNCTION_4BIT_1LINE>>4
 50e:	5c 98       	cbi	0x0b, 4	; 11
    lcd_e_toggle();
 510:	0e 94 07 02 	call	0x40e	; 0x40e <toggle_e>
 514:	95 e1       	ldi	r25, 0x15	; 21
 516:	9a 95       	dec	r25
 518:	f1 f7       	brne	.-4      	; 0x516 <lcd_init+0x52>
 51a:	00 00       	nop
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
    lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
    lcd_command(KS0073_4LINES_MODE);
    lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
    #else
    lcd_command(LCD_FUNCTION_DEFAULT); /* function set: display lines  */
 51c:	88 e2       	ldi	r24, 0x28	; 40
 51e:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
    #endif
    lcd_command(LCD_DISP_OFF);     /* display off                  */
 522:	88 e0       	ldi	r24, 0x08	; 8
 524:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
    lcd_clrscr();                  /* display clear                */
 528:	0e 94 4a 02 	call	0x494	; 0x494 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT); /* set entry mode               */
 52c:	86 e0       	ldi	r24, 0x06	; 6
 52e:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
    lcd_command(dispAttr);         /* display/cursor control       */
 532:	8c 2f       	mov	r24, r28
 534:	0e 94 3c 02 	call	0x478	; 0x478 <lcd_command>
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <main>:
uint8_t open=0;//The door is open (1) or closed (0)
uint8_t wait_clear=0;//Indicates if we have to wait until screen cleared

int main(void)
{	//Configure LEDs
	GPIO_config_output(&DDRD,LED_GREEN);
 53c:	62 e0       	ldi	r22, 0x02	; 2
 53e:	8a e2       	ldi	r24, 0x2A	; 42
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_write_low(&PORTD,LED_GREEN); //ACTIVE HIGH
 546:	62 e0       	ldi	r22, 0x02	; 2
 548:	8b e2       	ldi	r24, 0x2B	; 43
 54a:	90 e0       	ldi	r25, 0x00	; 0
 54c:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	GPIO_config_output(&DDRD,LED_RED);
 550:	63 e0       	ldi	r22, 0x03	; 3
 552:	8a e2       	ldi	r24, 0x2A	; 42
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_write_low(&PORTD,LED_RED); //ACTIVE HIGH
 55a:	63 e0       	ldi	r22, 0x03	; 3
 55c:	8b e2       	ldi	r24, 0x2B	; 43
 55e:	90 e0       	ldi	r25, 0x00	; 0
 560:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	//Configure LCD display
	lcd_init(LCD_DISP_ON);
 564:	8c e0       	ldi	r24, 0x0C	; 12
 566:	0e 94 62 02 	call	0x4c4	; 0x4c4 <lcd_init>
	lcd_gotoxy(1,0);
 56a:	60 e0       	ldi	r22, 0x00	; 0
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
	lcd_puts("CODE: ");
 572:	80 e1       	ldi	r24, 0x10	; 16
 574:	91 e0       	ldi	r25, 0x01	; 1
 576:	0e 94 52 02 	call	0x4a4	; 0x4a4 <lcd_puts>
	
	//Configure keypad ports
	GPIO_config_output(&DDRC,0);
 57a:	60 e0       	ldi	r22, 0x00	; 0
 57c:	87 e2       	ldi	r24, 0x27	; 39
 57e:	90 e0       	ldi	r25, 0x00	; 0
 580:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_config_output(&DDRC,1);
 584:	61 e0       	ldi	r22, 0x01	; 1
 586:	87 e2       	ldi	r24, 0x27	; 39
 588:	90 e0       	ldi	r25, 0x00	; 0
 58a:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_config_output(&DDRC,2);
 58e:	62 e0       	ldi	r22, 0x02	; 2
 590:	87 e2       	ldi	r24, 0x27	; 39
 592:	90 e0       	ldi	r25, 0x00	; 0
 594:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_config_input_pullup(&DDRC,3);
 598:	63 e0       	ldi	r22, 0x03	; 3
 59a:	87 e2       	ldi	r24, 0x27	; 39
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	GPIO_config_input_pullup(&DDRC,4);
 5a2:	64 e0       	ldi	r22, 0x04	; 4
 5a4:	87 e2       	ldi	r24, 0x27	; 39
 5a6:	90 e0       	ldi	r25, 0x00	; 0
 5a8:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	GPIO_config_input_pullup(&DDRC,5);
 5ac:	65 e0       	ldi	r22, 0x05	; 5
 5ae:	87 e2       	ldi	r24, 0x27	; 39
 5b0:	90 e0       	ldi	r25, 0x00	; 0
 5b2:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	GPIO_config_input_pullup(&DDRC,6);
 5b6:	66 e0       	ldi	r22, 0x06	; 6
 5b8:	87 e2       	ldi	r24, 0x27	; 39
 5ba:	90 e0       	ldi	r25, 0x00	; 0
 5bc:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	
	//Configure relay
	GPIO_config_output(&DDRB,3);
 5c0:	63 e0       	ldi	r22, 0x03	; 3
 5c2:	84 e2       	ldi	r24, 0x24	; 36
 5c4:	90 e0       	ldi	r25, 0x00	; 0
 5c6:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	
	//Timer1 for scanning keypad
	TIM1_overflow_33ms();//scan every 33 ms
 5ca:	e1 e8       	ldi	r30, 0x81	; 129
 5cc:	f0 e0       	ldi	r31, 0x00	; 0
 5ce:	80 81       	ld	r24, Z
 5d0:	8a 7f       	andi	r24, 0xFA	; 250
 5d2:	80 83       	st	Z, r24
 5d4:	80 81       	ld	r24, Z
 5d6:	82 60       	ori	r24, 0x02	; 2
 5d8:	80 83       	st	Z, r24
	TIM1_overflow_interrupt_enable();
 5da:	ef e6       	ldi	r30, 0x6F	; 111
 5dc:	f0 e0       	ldi	r31, 0x00	; 0
 5de:	80 81       	ld	r24, Z
 5e0:	81 60       	ori	r24, 0x01	; 1
 5e2:	80 83       	st	Z, r24
	//Timer0 for closing door
	TIM0_overflow_16ms();
 5e4:	85 b5       	in	r24, 0x25	; 37
 5e6:	8d 7f       	andi	r24, 0xFD	; 253
 5e8:	85 bd       	out	0x25, r24	; 37
 5ea:	85 b5       	in	r24, 0x25	; 37
 5ec:	85 60       	ori	r24, 0x05	; 5
 5ee:	85 bd       	out	0x25, r24	; 37
	
	//Set interrupts
	sei();
 5f0:	78 94       	sei
	
	//Configure UART
	
	uart_init(UART_BAUD_SELECT(9600,F_CPU))	;
 5f2:	87 e6       	ldi	r24, 0x67	; 103
 5f4:	90 e0       	ldi	r25, 0x00	; 0
 5f6:	0e 94 b0 04 	call	0x960	; 0x960 <uart_init>
	uart_puts("System initialized\r\n");
 5fa:	87 e1       	ldi	r24, 0x17	; 23
 5fc:	91 e0       	ldi	r25, 0x01	; 1
 5fe:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
 602:	ff cf       	rjmp	.-2      	; 0x602 <main+0xc6>

00000604 <__vector_13>:
   
    while (1);//forever loop
    
}
ISR(TIMER1_OVF_vect){
 604:	1f 92       	push	r1
 606:	0f 92       	push	r0
 608:	0f b6       	in	r0, 0x3f	; 63
 60a:	0f 92       	push	r0
 60c:	11 24       	eor	r1, r1
 60e:	2f 93       	push	r18
 610:	3f 93       	push	r19
 612:	4f 93       	push	r20
 614:	5f 93       	push	r21
 616:	6f 93       	push	r22
 618:	7f 93       	push	r23
 61a:	8f 93       	push	r24
 61c:	9f 93       	push	r25
 61e:	af 93       	push	r26
 620:	bf 93       	push	r27
 622:	cf 93       	push	r28
 624:	df 93       	push	r29
 626:	ef 93       	push	r30
 628:	ff 93       	push	r31
	static char correct_code3[4]={'6','3','8','7'};
	static uint8_t cnt=0;//Count the number of digits entered
	static uint8_t time_limit_on=0;//Time limit goes on when first digit is pressed
	static uint16_t time_limit_cnt=0;//Count the time to enter the code (16 s approx.)
	static char code[4]={'X','X','X','X'};//Code entered
	char readed=read_digits();//If none button is pressed the output is 'X'
 62a:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <read_digits>
 62e:	c8 2f       	mov	r28, r24
	
	if((readed!='X')&&(wait_clear==0)){//We accept the digit only if the screen is cleared from the previous code
 630:	88 35       	cpi	r24, 0x58	; 88
 632:	09 f4       	brne	.+2      	; 0x636 <__vector_13+0x32>
 634:	aa c0       	rjmp	.+340    	; 0x78a <__vector_13+0x186>
 636:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <wait_clear>
 63a:	81 11       	cpse	r24, r1
 63c:	a6 c0       	rjmp	.+332    	; 0x78a <__vector_13+0x186>
		switch(cnt){
 63e:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <cnt.2126>
 642:	81 30       	cpi	r24, 0x01	; 1
 644:	59 f0       	breq	.+22     	; 0x65c <__vector_13+0x58>
 646:	28 f0       	brcs	.+10     	; 0x652 <__vector_13+0x4e>
 648:	82 30       	cpi	r24, 0x02	; 2
 64a:	69 f0       	breq	.+26     	; 0x666 <__vector_13+0x62>
 64c:	83 30       	cpi	r24, 0x03	; 3
 64e:	81 f0       	breq	.+32     	; 0x670 <__vector_13+0x6c>
 650:	13 c0       	rjmp	.+38     	; 0x678 <__vector_13+0x74>
			case 0:
				uart_puts("First digit inserted\r\n");
 652:	8c e2       	ldi	r24, 0x2C	; 44
 654:	91 e0       	ldi	r25, 0x01	; 1
 656:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
				break;
 65a:	0e c0       	rjmp	.+28     	; 0x678 <__vector_13+0x74>
			case 1:
				uart_puts("Second digit inserted\r\n");
 65c:	83 e4       	ldi	r24, 0x43	; 67
 65e:	91 e0       	ldi	r25, 0x01	; 1
 660:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
				break;
 664:	09 c0       	rjmp	.+18     	; 0x678 <__vector_13+0x74>
			case 2:
				uart_puts("Third digit inserted\r\n");
 666:	8b e5       	ldi	r24, 0x5B	; 91
 668:	91 e0       	ldi	r25, 0x01	; 1
 66a:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
				break;
 66e:	04 c0       	rjmp	.+8      	; 0x678 <__vector_13+0x74>
			case 3:
				uart_puts("Fourth digit inserted\r\n");
 670:	82 e7       	ldi	r24, 0x72	; 114
 672:	91 e0       	ldi	r25, 0x01	; 1
 674:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
				break;
			default:
				break;
		}
		
		code[cnt]=readed;
 678:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <cnt.2126>
 67c:	e8 2f       	mov	r30, r24
 67e:	f0 e0       	ldi	r31, 0x00	; 0
 680:	e4 5f       	subi	r30, 0xF4	; 244
 682:	fe 4f       	sbci	r31, 0xFE	; 254
 684:	c0 83       	st	Z, r28
		lcd_gotoxy(cnt+7,0);
 686:	60 e0       	ldi	r22, 0x00	; 0
 688:	89 5f       	subi	r24, 0xF9	; 249
 68a:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
		lcd_putc(readed);
 68e:	8c 2f       	mov	r24, r28
 690:	0e 94 4e 02 	call	0x49c	; 0x49c <lcd_putc>
		cnt++;
 694:	80 91 36 02 	lds	r24, 0x0236	; 0x800236 <cnt.2126>
 698:	8f 5f       	subi	r24, 0xFF	; 255
 69a:	80 93 36 02 	sts	0x0236, r24	; 0x800236 <cnt.2126>
		if(cnt==1){
 69e:	81 30       	cpi	r24, 0x01	; 1
 6a0:	49 f4       	brne	.+18     	; 0x6b4 <__vector_13+0xb0>
			time_limit_cnt=0;//Set time 
			time_limit_on=1;//Activation of time limit
 6a2:	80 93 33 02 	sts	0x0233, r24	; 0x800233 <time_limit_on.2127>
			}
			uart_puts("\r\n");
		}
	}
	
	time_limit_cnt++;
 6a6:	81 e0       	ldi	r24, 0x01	; 1
 6a8:	90 e0       	ldi	r25, 0x00	; 0
 6aa:	90 93 35 02 	sts	0x0235, r25	; 0x800235 <time_limit_cnt.2128+0x1>
 6ae:	80 93 34 02 	sts	0x0234, r24	; 0x800234 <time_limit_cnt.2128>
 6b2:	8d c0       	rjmp	.+282    	; 0x7ce <__vector_13+0x1ca>
		cnt++;
		if(cnt==1){
			time_limit_cnt=0;//Set time 
			time_limit_on=1;//Activation of time limit
		}
		if(cnt==4){
 6b4:	84 30       	cpi	r24, 0x04	; 4
 6b6:	09 f0       	breq	.+2      	; 0x6ba <__vector_13+0xb6>
 6b8:	68 c0       	rjmp	.+208    	; 0x78a <__vector_13+0x186>
			cnt=0;
 6ba:	10 92 36 02 	sts	0x0236, r1	; 0x800236 <cnt.2126>
			uart_puts("The code inserted is: ");
 6be:	8a e8       	ldi	r24, 0x8A	; 138
 6c0:	91 e0       	ldi	r25, 0x01	; 1
 6c2:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
			uart_putc(code[0]);uart_putc(code[1]);uart_putc(code[2]);uart_putc(code[3]);
 6c6:	cc e0       	ldi	r28, 0x0C	; 12
 6c8:	d1 e0       	ldi	r29, 0x01	; 1
 6ca:	88 81       	ld	r24, Y
 6cc:	0e 94 c9 04 	call	0x992	; 0x992 <uart_putc>
 6d0:	89 81       	ldd	r24, Y+1	; 0x01
 6d2:	0e 94 c9 04 	call	0x992	; 0x992 <uart_putc>
 6d6:	8a 81       	ldd	r24, Y+2	; 0x02
 6d8:	0e 94 c9 04 	call	0x992	; 0x992 <uart_putc>
 6dc:	8b 81       	ldd	r24, Y+3	; 0x03
 6de:	0e 94 c9 04 	call	0x992	; 0x992 <uart_putc>
			uart_puts("\r\n");
 6e2:	8f e0       	ldi	r24, 0x0F	; 15
 6e4:	92 e0       	ldi	r25, 0x02	; 2
 6e6:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
			wait_clear=1;//Wait until the screen is cleared
 6ea:	81 e0       	ldi	r24, 0x01	; 1
 6ec:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <wait_clear>
			time_limit_on=0;//Time limit off
 6f0:	10 92 33 02 	sts	0x0233, r1	; 0x800233 <time_limit_on.2127>
			TIM0_overflow_interrupt_enable();//Start counting to close the door
 6f4:	ee e6       	ldi	r30, 0x6E	; 110
 6f6:	f0 e0       	ldi	r31, 0x00	; 0
 6f8:	80 81       	ld	r24, Z
 6fa:	81 60       	ori	r24, 0x01	; 1
 6fc:	80 83       	st	Z, r24
			if(code_analyzer(code,correct_code1,correct_code2,correct_code3)==1){
 6fe:	20 e0       	ldi	r18, 0x00	; 0
 700:	31 e0       	ldi	r19, 0x01	; 1
 702:	44 e0       	ldi	r20, 0x04	; 4
 704:	51 e0       	ldi	r21, 0x01	; 1
 706:	68 e0       	ldi	r22, 0x08	; 8
 708:	71 e0       	ldi	r23, 0x01	; 1
 70a:	ce 01       	movw	r24, r28
 70c:	0e 94 94 00 	call	0x128	; 0x128 <code_analyzer>
 710:	81 30       	cpi	r24, 0x01	; 1
 712:	f9 f4       	brne	.+62     	; 0x752 <__vector_13+0x14e>
				uart_puts("The code is correct. Door open");
 714:	81 ea       	ldi	r24, 0xA1	; 161
 716:	91 e0       	ldi	r25, 0x01	; 1
 718:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
				open=1;//door open
 71c:	81 e0       	ldi	r24, 0x01	; 1
 71e:	80 93 38 02 	sts	0x0238, r24	; 0x800238 <open>
				GPIO_write_high(&PORTB,3);//open door
 722:	63 e0       	ldi	r22, 0x03	; 3
 724:	85 e2       	ldi	r24, 0x25	; 37
 726:	90 e0       	ldi	r25, 0x00	; 0
 728:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
				GPIO_write_high(&PORTD,LED_GREEN);
 72c:	62 e0       	ldi	r22, 0x02	; 2
 72e:	8b e2       	ldi	r24, 0x2B	; 43
 730:	90 e0       	ldi	r25, 0x00	; 0
 732:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
				GPIO_write_low(&PORTD,LED_RED);
 736:	63 e0       	ldi	r22, 0x03	; 3
 738:	8b e2       	ldi	r24, 0x2B	; 43
 73a:	90 e0       	ldi	r25, 0x00	; 0
 73c:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
				lcd_gotoxy(1,1);
 740:	61 e0       	ldi	r22, 0x01	; 1
 742:	81 e0       	ldi	r24, 0x01	; 1
 744:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
				lcd_puts("CORRECT CODE");
 748:	80 ec       	ldi	r24, 0xC0	; 192
 74a:	91 e0       	ldi	r25, 0x01	; 1
 74c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <lcd_puts>
 750:	18 c0       	rjmp	.+48     	; 0x782 <__vector_13+0x17e>
				
				
			}
			else
			{	
				uart_puts("The code is wrong.");
 752:	8d ec       	ldi	r24, 0xCD	; 205
 754:	91 e0       	ldi	r25, 0x01	; 1
 756:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
				open=0;//door closed
 75a:	10 92 38 02 	sts	0x0238, r1	; 0x800238 <open>
				lcd_gotoxy(1,1);
 75e:	61 e0       	ldi	r22, 0x01	; 1
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
				lcd_puts("WRONG CODE");
 766:	80 ee       	ldi	r24, 0xE0	; 224
 768:	91 e0       	ldi	r25, 0x01	; 1
 76a:	0e 94 52 02 	call	0x4a4	; 0x4a4 <lcd_puts>
				GPIO_write_high(&PORTD,LED_RED);
 76e:	63 e0       	ldi	r22, 0x03	; 3
 770:	8b e2       	ldi	r24, 0x2B	; 43
 772:	90 e0       	ldi	r25, 0x00	; 0
 774:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
				GPIO_write_low(&PORTD,LED_GREEN);
 778:	62 e0       	ldi	r22, 0x02	; 2
 77a:	8b e2       	ldi	r24, 0x2B	; 43
 77c:	90 e0       	ldi	r25, 0x00	; 0
 77e:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
			}
			uart_puts("\r\n");
 782:	8f e0       	ldi	r24, 0x0F	; 15
 784:	92 e0       	ldi	r25, 0x02	; 2
 786:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
		}
	}
	
	time_limit_cnt++;
 78a:	80 91 34 02 	lds	r24, 0x0234	; 0x800234 <time_limit_cnt.2128>
 78e:	90 91 35 02 	lds	r25, 0x0235	; 0x800235 <time_limit_cnt.2128+0x1>
 792:	01 96       	adiw	r24, 0x01	; 1
 794:	90 93 35 02 	sts	0x0235, r25	; 0x800235 <time_limit_cnt.2128+0x1>
 798:	80 93 34 02 	sts	0x0234, r24	; 0x800234 <time_limit_cnt.2128>
	if((time_limit_cnt==500)&&(time_limit_on==1)){
 79c:	84 3f       	cpi	r24, 0xF4	; 244
 79e:	91 40       	sbci	r25, 0x01	; 1
 7a0:	b1 f4       	brne	.+44     	; 0x7ce <__vector_13+0x1ca>
 7a2:	80 91 33 02 	lds	r24, 0x0233	; 0x800233 <time_limit_on.2127>
 7a6:	81 30       	cpi	r24, 0x01	; 1
 7a8:	91 f4       	brne	.+36     	; 0x7ce <__vector_13+0x1ca>
		time_limit_cnt=0;
 7aa:	10 92 35 02 	sts	0x0235, r1	; 0x800235 <time_limit_cnt.2128+0x1>
 7ae:	10 92 34 02 	sts	0x0234, r1	; 0x800234 <time_limit_cnt.2128>
		cnt=0;
 7b2:	10 92 36 02 	sts	0x0236, r1	; 0x800236 <cnt.2126>
		lcd_gotoxy(7,0);
 7b6:	60 e0       	ldi	r22, 0x00	; 0
 7b8:	87 e0       	ldi	r24, 0x07	; 7
 7ba:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
		lcd_puts("    ");
 7be:	8c e2       	ldi	r24, 0x2C	; 44
 7c0:	92 e0       	ldi	r25, 0x02	; 2
 7c2:	0e 94 52 02 	call	0x4a4	; 0x4a4 <lcd_puts>
		uart_puts("Time for introducing code exceeded. \r\n");
 7c6:	8b ee       	ldi	r24, 0xEB	; 235
 7c8:	91 e0       	ldi	r25, 0x01	; 1
 7ca:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
	}
}
 7ce:	ff 91       	pop	r31
 7d0:	ef 91       	pop	r30
 7d2:	df 91       	pop	r29
 7d4:	cf 91       	pop	r28
 7d6:	bf 91       	pop	r27
 7d8:	af 91       	pop	r26
 7da:	9f 91       	pop	r25
 7dc:	8f 91       	pop	r24
 7de:	7f 91       	pop	r23
 7e0:	6f 91       	pop	r22
 7e2:	5f 91       	pop	r21
 7e4:	4f 91       	pop	r20
 7e6:	3f 91       	pop	r19
 7e8:	2f 91       	pop	r18
 7ea:	0f 90       	pop	r0
 7ec:	0f be       	out	0x3f, r0	; 63
 7ee:	0f 90       	pop	r0
 7f0:	1f 90       	pop	r1
 7f2:	18 95       	reti

000007f4 <__vector_16>:
ISR(TIMER0_OVF_vect){
 7f4:	1f 92       	push	r1
 7f6:	0f 92       	push	r0
 7f8:	0f b6       	in	r0, 0x3f	; 63
 7fa:	0f 92       	push	r0
 7fc:	11 24       	eor	r1, r1
 7fe:	2f 93       	push	r18
 800:	3f 93       	push	r19
 802:	4f 93       	push	r20
 804:	5f 93       	push	r21
 806:	6f 93       	push	r22
 808:	7f 93       	push	r23
 80a:	8f 93       	push	r24
 80c:	9f 93       	push	r25
 80e:	af 93       	push	r26
 810:	bf 93       	push	r27
 812:	ef 93       	push	r30
 814:	ff 93       	push	r31
	//Interrupt used to close the relay
	static uint8_t cnt=0;
	if(cnt==188){
 816:	80 91 32 02 	lds	r24, 0x0232	; 0x800232 <__data_end>
 81a:	8c 3b       	cpi	r24, 0xBC	; 188
 81c:	99 f5       	brne	.+102    	; 0x884 <__vector_16+0x90>
		cnt=0;
 81e:	10 92 32 02 	sts	0x0232, r1	; 0x800232 <__data_end>
		if(open==1){
 822:	80 91 38 02 	lds	r24, 0x0238	; 0x800238 <open>
 826:	81 30       	cpi	r24, 0x01	; 1
 828:	89 f4       	brne	.+34     	; 0x84c <__vector_16+0x58>
			GPIO_write_low(&PORTB,3);//close door
 82a:	63 e0       	ldi	r22, 0x03	; 3
 82c:	85 e2       	ldi	r24, 0x25	; 37
 82e:	90 e0       	ldi	r25, 0x00	; 0
 830:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
			GPIO_write_low(&PORTD,LED_GREEN);
 834:	62 e0       	ldi	r22, 0x02	; 2
 836:	8b e2       	ldi	r24, 0x2B	; 43
 838:	90 e0       	ldi	r25, 0x00	; 0
 83a:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
			open=0;
 83e:	10 92 38 02 	sts	0x0238, r1	; 0x800238 <open>
			uart_puts("Closing door...\r\n");
 842:	82 e1       	ldi	r24, 0x12	; 18
 844:	92 e0       	ldi	r25, 0x02	; 2
 846:	0e 94 de 04 	call	0x9bc	; 0x9bc <uart_puts>
 84a:	05 c0       	rjmp	.+10     	; 0x856 <__vector_16+0x62>
		}
		else{//if the door is closed we clear the screen for a new code
			GPIO_write_low(&PORTD,LED_RED);
 84c:	63 e0       	ldi	r22, 0x03	; 3
 84e:	8b e2       	ldi	r24, 0x2B	; 43
 850:	90 e0       	ldi	r25, 0x00	; 0
 852:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
		}
		TIM0_overflow_interrupt_disable();
 856:	ee e6       	ldi	r30, 0x6E	; 110
 858:	f0 e0       	ldi	r31, 0x00	; 0
 85a:	80 81       	ld	r24, Z
 85c:	8e 7f       	andi	r24, 0xFE	; 254
 85e:	80 83       	st	Z, r24
		lcd_gotoxy(7,0);
 860:	60 e0       	ldi	r22, 0x00	; 0
 862:	87 e0       	ldi	r24, 0x07	; 7
 864:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
		lcd_puts("    ");//Clear screen
 868:	8c e2       	ldi	r24, 0x2C	; 44
 86a:	92 e0       	ldi	r25, 0x02	; 2
 86c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <lcd_puts>
		lcd_gotoxy(1,1);
 870:	61 e0       	ldi	r22, 0x01	; 1
 872:	81 e0       	ldi	r24, 0x01	; 1
 874:	0e 94 40 02 	call	0x480	; 0x480 <lcd_gotoxy>
		lcd_puts("            ");
 878:	84 e2       	ldi	r24, 0x24	; 36
 87a:	92 e0       	ldi	r25, 0x02	; 2
 87c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <lcd_puts>
		wait_clear=0;//the screen is cleared now
 880:	10 92 37 02 	sts	0x0237, r1	; 0x800237 <wait_clear>
			
	}
	cnt++;
 884:	80 91 32 02 	lds	r24, 0x0232	; 0x800232 <__data_end>
 888:	8f 5f       	subi	r24, 0xFF	; 255
 88a:	80 93 32 02 	sts	0x0232, r24	; 0x800232 <__data_end>
	
}
 88e:	ff 91       	pop	r31
 890:	ef 91       	pop	r30
 892:	bf 91       	pop	r27
 894:	af 91       	pop	r26
 896:	9f 91       	pop	r25
 898:	8f 91       	pop	r24
 89a:	7f 91       	pop	r23
 89c:	6f 91       	pop	r22
 89e:	5f 91       	pop	r21
 8a0:	4f 91       	pop	r20
 8a2:	3f 91       	pop	r19
 8a4:	2f 91       	pop	r18
 8a6:	0f 90       	pop	r0
 8a8:	0f be       	out	0x3f, r0	; 63
 8aa:	0f 90       	pop	r0
 8ac:	1f 90       	pop	r1
 8ae:	18 95       	reti

000008b0 <__vector_18>:
    /* store buffer index */
    UART_RxTail = tmptail;

    UART_LastRxError = 0;
    return (lastRxError << 8) + data;
}/* uart_getc */
 8b0:	1f 92       	push	r1
 8b2:	0f 92       	push	r0
 8b4:	0f b6       	in	r0, 0x3f	; 63
 8b6:	0f 92       	push	r0
 8b8:	11 24       	eor	r1, r1
 8ba:	2f 93       	push	r18
 8bc:	8f 93       	push	r24
 8be:	9f 93       	push	r25
 8c0:	ef 93       	push	r30
 8c2:	ff 93       	push	r31
 8c4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 8c8:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 8cc:	8c 71       	andi	r24, 0x1C	; 28
 8ce:	e0 91 3b 02 	lds	r30, 0x023B	; 0x80023b <UART_RxHead>
 8d2:	ef 5f       	subi	r30, 0xFF	; 255
 8d4:	ef 71       	andi	r30, 0x1F	; 31
 8d6:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <UART_RxTail>
 8da:	e9 17       	cp	r30, r25
 8dc:	39 f0       	breq	.+14     	; 0x8ec <__vector_18+0x3c>
 8de:	e0 93 3b 02 	sts	0x023B, r30	; 0x80023b <UART_RxHead>
 8e2:	f0 e0       	ldi	r31, 0x00	; 0
 8e4:	e2 5c       	subi	r30, 0xC2	; 194
 8e6:	fd 4f       	sbci	r31, 0xFD	; 253
 8e8:	20 83       	st	Z, r18
 8ea:	01 c0       	rjmp	.+2      	; 0x8ee <__vector_18+0x3e>
 8ec:	82 e0       	ldi	r24, 0x02	; 2
 8ee:	90 91 39 02 	lds	r25, 0x0239	; 0x800239 <UART_LastRxError>
 8f2:	89 2b       	or	r24, r25
 8f4:	80 93 39 02 	sts	0x0239, r24	; 0x800239 <UART_LastRxError>
 8f8:	ff 91       	pop	r31
 8fa:	ef 91       	pop	r30
 8fc:	9f 91       	pop	r25
 8fe:	8f 91       	pop	r24
 900:	2f 91       	pop	r18
 902:	0f 90       	pop	r0
 904:	0f be       	out	0x3f, r0	; 63
 906:	0f 90       	pop	r0
 908:	1f 90       	pop	r1
 90a:	18 95       	reti

0000090c <__vector_19>:
 90c:	1f 92       	push	r1
 90e:	0f 92       	push	r0
 910:	0f b6       	in	r0, 0x3f	; 63
 912:	0f 92       	push	r0
 914:	11 24       	eor	r1, r1
 916:	8f 93       	push	r24
 918:	9f 93       	push	r25
 91a:	ef 93       	push	r30
 91c:	ff 93       	push	r31
 91e:	90 91 3d 02 	lds	r25, 0x023D	; 0x80023d <UART_TxHead>
 922:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <UART_TxTail>
 926:	98 17       	cp	r25, r24
 928:	69 f0       	breq	.+26     	; 0x944 <__vector_19+0x38>
 92a:	e0 91 3c 02 	lds	r30, 0x023C	; 0x80023c <UART_TxTail>
 92e:	ef 5f       	subi	r30, 0xFF	; 255
 930:	ef 77       	andi	r30, 0x7F	; 127
 932:	e0 93 3c 02 	sts	0x023C, r30	; 0x80023c <UART_TxTail>
 936:	f0 e0       	ldi	r31, 0x00	; 0
 938:	e2 5a       	subi	r30, 0xA2	; 162
 93a:	fd 4f       	sbci	r31, 0xFD	; 253
 93c:	80 81       	ld	r24, Z
 93e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 942:	05 c0       	rjmp	.+10     	; 0x94e <__vector_19+0x42>
 944:	e1 ec       	ldi	r30, 0xC1	; 193
 946:	f0 e0       	ldi	r31, 0x00	; 0
 948:	80 81       	ld	r24, Z
 94a:	8f 7d       	andi	r24, 0xDF	; 223
 94c:	80 83       	st	Z, r24
 94e:	ff 91       	pop	r31
 950:	ef 91       	pop	r30
 952:	9f 91       	pop	r25
 954:	8f 91       	pop	r24
 956:	0f 90       	pop	r0
 958:	0f be       	out	0x3f, r0	; 63
 95a:	0f 90       	pop	r0
 95c:	1f 90       	pop	r1
 95e:	18 95       	reti

00000960 <uart_init>:
 960:	10 92 3d 02 	sts	0x023D, r1	; 0x80023d <UART_TxHead>
 964:	10 92 3c 02 	sts	0x023C, r1	; 0x80023c <UART_TxTail>
 968:	10 92 3b 02 	sts	0x023B, r1	; 0x80023b <UART_RxHead>
 96c:	10 92 3a 02 	sts	0x023A, r1	; 0x80023a <UART_RxTail>
 970:	99 23       	and	r25, r25
 972:	1c f4       	brge	.+6      	; 0x97a <uart_init+0x1a>
 974:	22 e0       	ldi	r18, 0x02	; 2
 976:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 97a:	90 78       	andi	r25, 0x80	; 128
 97c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
 980:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
 984:	88 e9       	ldi	r24, 0x98	; 152
 986:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
 98a:	86 e0       	ldi	r24, 0x06	; 6
 98c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
 990:	08 95       	ret

00000992 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;


    tmphead = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 992:	20 91 3d 02 	lds	r18, 0x023D	; 0x80023d <UART_TxHead>
 996:	2f 5f       	subi	r18, 0xFF	; 255
 998:	2f 77       	andi	r18, 0x7F	; 127

    while (tmphead == UART_TxTail)
 99a:	90 91 3c 02 	lds	r25, 0x023C	; 0x80023c <UART_TxTail>
 99e:	29 17       	cp	r18, r25
 9a0:	e1 f3       	breq	.-8      	; 0x99a <uart_putc+0x8>
    {
        ;/* wait for free space in buffer */
    }

    UART_TxBuf[tmphead] = data;
 9a2:	e2 2f       	mov	r30, r18
 9a4:	f0 e0       	ldi	r31, 0x00	; 0
 9a6:	e2 5a       	subi	r30, 0xA2	; 162
 9a8:	fd 4f       	sbci	r31, 0xFD	; 253
 9aa:	80 83       	st	Z, r24
    UART_TxHead         = tmphead;
 9ac:	20 93 3d 02 	sts	0x023D, r18	; 0x80023d <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL |= _BV(UART0_UDRIE);
 9b0:	e1 ec       	ldi	r30, 0xC1	; 193
 9b2:	f0 e0       	ldi	r31, 0x00	; 0
 9b4:	80 81       	ld	r24, Z
 9b6:	80 62       	ori	r24, 0x20	; 32
 9b8:	80 83       	st	Z, r24
 9ba:	08 95       	ret

000009bc <uart_puts>:
 * Purpose:  transmit string to UART
 * Input:    string to be transmitted
 * Returns:  none
 **************************************************************************/
void uart_puts(const char *s)
{
 9bc:	cf 93       	push	r28
 9be:	df 93       	push	r29
 9c0:	ec 01       	movw	r28, r24
    while (*s)
 9c2:	88 81       	ld	r24, Y
 9c4:	88 23       	and	r24, r24
 9c6:	31 f0       	breq	.+12     	; 0x9d4 <uart_puts+0x18>
 9c8:	21 96       	adiw	r28, 0x01	; 1
        uart_putc(*s++);
 9ca:	0e 94 c9 04 	call	0x992	; 0x992 <uart_putc>
 * Input:    string to be transmitted
 * Returns:  none
 **************************************************************************/
void uart_puts(const char *s)
{
    while (*s)
 9ce:	89 91       	ld	r24, Y+
 9d0:	81 11       	cpse	r24, r1
 9d2:	fb cf       	rjmp	.-10     	; 0x9ca <uart_puts+0xe>
        uart_putc(*s++);
}/* uart_puts */
 9d4:	df 91       	pop	r29
 9d6:	cf 91       	pop	r28
 9d8:	08 95       	ret

000009da <_exit>:
 9da:	f8 94       	cli

000009dc <__stop_program>:
 9dc:	ff cf       	rjmp	.-2      	; 0x9dc <__stop_program>
